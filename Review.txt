Замечания по ревью

HW 3

- 1 -

*Resume*
~ equals - сгенери стандартный при помощи идеи

*Storage*
~ `Resume r` - давай переменным осмысленные имена, такие сокращения можно использовать внутри циклов или в стримах

*AbstractArrayStorage*
~ поставь полям класса корректные модификаторы доступа
~ update/delete/get  - работает с ошибкой в реализации SortedArrayStorage
~ get -  RESUME_NOT_FOUND вместо -1
~ save - перенеси проверку индекса из наследников в абстрактный класс
~ delete - нет сохранения порядка следования резюме в SortedArrayStorage

*SortedArrayStorage*
~ binarySearch(Object[] a, int fromIndex, int toIndex, Object key) - используй этот метод с такими параметрами, компаратор для резюме уже определен в классе модели
~ Arrays.binarySearch - протестируй и почитай что возвращает этот метод, если объект (резюме) не найдено
~ indexOf - cоедени их вместе в один метод
~ insertResume - проверка if (index == RESUME_NOT_FOUND), что будет если придет индекс с значением например .. 7?

*MainArray*
~ интересная реализация :slightly_smiling_face:, только тестил в ней мало… т.к.SortedArrayStorage почти в каждом методе получает ArrayIndexOutOfBoundsException

~ когда переопределяешь(реализуешь)  методы, не забывай ставить над ними аннотацию @Override, это защитит от ошибок в случае рефакторинга кода

- 2 -
*AbstractArrayStorage*
~ здесь тоже ставь аннотации @Override
~ indexOf - попытка хорошая, но каким будет результат в не сортированном хранилище?
~ посмотри какой еще общий код можно вынести в абстрактный класс из наследников

*SortedArrayStorage*
~ deleteElementByIndex - выходишь за пределы storage
~ index = (-1 * index) - 1; - лучше сделать новую переменную, так будет понятно, где и какое значение используется и вычисляется

HW 4

*MainReflection*
~ выполнение задания хорошо, только первыми пиши публичные методы, а потом приватные

*AbstractArrayStorage*
~ удали конструктор из этого класса и в наследниках он тоже не нужен, я догадываюсь с какой целью ты его ввел, но это лишнее

*AbstractArrayStorageTest*
~ модификаторы доступа у всех полей сейчас будут private
~ "uuid1"/"uuid2"/… new Resume("uuid1")/new Resume("uuid2")... -  вынеси в поля класса и используй в тестах
~ поставь конструктору корректный модификатор доступа
~ setUp() - перед каждым тестом заполнять массив тремя резюме через стрим дороговатая операция, тестирование вообще затратная часть разработки, здесь тоже надо думать про оптимизацию, просто делай три раза storage.save
~ update() - надо проверять не то, что есть резюме с таким uuid в хранилище, а надо проверять что этот тот самый объект которым обновили, находится теперь в хранилище, для этого поищи в assert подходящий метод
~ сделай тесты - `updateNotExist(), saveExist() , deleteNotExist()`
~ сгруппируй методы по смыслу
~ storageIsFull()  - этот тест лишний, тест на переполнение есть, этот уже как часть того что имеется
~ getAll() - проверяй + к этому длину полученного массива
~ save() - проверяй наличие резюме через assertEquals или другой assert метод проверки по ссылке
~ storageOverflow() - переименуй saveOverflow(), это тестирование метода save
читай внимательно логику реализации этого теста
>заполняем массив, но не вызываем у него переполнение
>если исключение вылетит раньше, чем массив будет заполнен, то тест должен провалиться (см. Assert.fail())
>если исключение вылетает, когда пытаемся добавить в полностью заполненный массив еще одно резюме - тест пройден
* сразу уточнение, заполнять надо весь массив 10_000
~ delete - плюс к этому - проверяй наличие удаленного резюме в storage с ожиданием исключения